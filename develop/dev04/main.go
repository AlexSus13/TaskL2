/*
=== Поиск анаграмм по словарю ===

Напишите функцию поиска всех множеств анаграмм по словарю.
Например:
'пятак', 'пятка' и 'тяпка' - принадлежат одному множеству,
'листок', 'слиток' и 'столик' - другому.

Входные данные для функции: ссылка на массив - каждый элемент которого - слово на русском языке в кодировке utf8.
Выходные данные: Ссылка на мапу множеств анаграмм.
Ключ - первое встретившееся в словаре слово из множества
Значение - ссылка на массив, каждый элемент которого, слово из множества. Массив должен быть отсортирован по возрастанию.
Множества из одного элемента не должны попасть в результат.
Все слова должны быть приведены к нижнему регистру.
В результате каждое слово должно встречаться только один раз.

Программа должна проходить все тесты. Код должен проходить проверки go vet и golint.
*/
package main

import (
	"fmt"
	"sort"
	"strings"
)

func main() {
	words := []string{
		"пятак",
		"листок",
		"пятка",
		"слиток",
		"тяпка",
		"столик",
		"Пятак",
		"Листок",
		"слово",
		"волос",
	}

	result := Search(words)
	fmt.Println(result)
}

func Search(words []string) map[string][]string {

	result := make(map[string][]string) //результат
	tempMap := make(map[string]string)  //map для проверки сортированных слов

	for _, word := range words { //Проходимся по слайсу
		word := strings.ToLower(word) //Делаем все буквы маленькими

		//Анаграмма-это слово образованное путем перестановки букв другого слова
		//Сортируем буквы в слове (у анаграмм отсортированные слова одинаковые)
		sortWord := func(word string) string {
			runeSlice := []rune(word) //делаем из слова слайс рун

			sort.Slice(runeSlice, func(i, j int) bool {
				return runeSlice[i] < runeSlice[j]
			})

			return string(runeSlice)
		}(word)

		//Если отсортированное слово есть во временной map и это слово не равно
		//ранее добавленной анаграмме
		if value, ok := tempMap[sortWord]; ok && value != word {
			result[value] = append(result[value], word) //добавляем слово в результирующую map,
			//в качестве ключа используя первую анограмму
		} else {
			tempMap[sortWord] = word
		}
	}

	//Поскольку множество не может состоять из одного значения
	for k, v := range result {
		if len(v) < 2 {
			delete(result, k) //удаляем если меньше 2 элементов
		}
		sort.Strings(v) //сортируем
	}

	return result
}
